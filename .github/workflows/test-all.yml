name: Ecommerce CI/CD (Optimizado)

on:
  push:
    branches-ignore:
      - prod
      - qa
  pull_request:
    branches: [ master, dev ]

env:
  HELM_VERSION: 3.12.0
  KIND_VERSION: v0.20.0
  DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
  DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}

jobs:
  set-env:
    runs-on: ubuntu-latest
    outputs:
      IMAGE_TAG: ${{ steps.set-tag.outputs.IMAGE_TAG }}
      VALUES_FILE: ${{ steps.set-tag.outputs.VALUES_FILE }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set image tag and values file
        id: set-tag
        run: |
          BRANCH_NAME=${GITHUB_REF#refs/heads/}
          SAFE_BRANCH_NAME=$(echo "$BRANCH_NAME" | tr '[:upper:]' '[:lower:]' | tr '/' '-')
          
          # Default logic
          IMAGE_TAG="$SAFE_BRANCH_NAME"
          VALUES_FILE="./helm/ecommerce/values-ci.yaml"

          if [[ "$SAFE_BRANCH_NAME" == "dev" ]]; then
            IMAGE_TAG="dev"
          fi

          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "VALUES_FILE=$VALUES_FILE" >> $GITHUB_OUTPUT

  build-services:
    runs-on: ubuntu-latest
    needs: set-env
    strategy:
      max-parallel: 3
      matrix:
        service: [user-service, product-service, payment-service, shipping-service, favourite-service, api-gateway, service-discovery, order-service, cloud-config, proxy-client]
    name: Build ${{ matrix.service }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check if service changed
        id: changed
        run: |
          if [ -z "${{ github.event.before }}" ] || [ "${{ github.event.before }}" == "0000000000000000000000000000000000000000" ]; then
             echo "changed=true" >> $GITHUB_OUTPUT
          else
             if git diff --name-only ${{ github.event.before }} ${{ github.sha }} | grep -q "^${{ matrix.service }}/"; then
               echo "changed=true" >> $GITHUB_OUTPUT
             else
               echo "changed=false" >> $GITHUB_OUTPUT
             fi
          fi

      - name: Cache Maven packages
        if: steps.changed.outputs.changed == 'true'
        uses: actions/cache@v3
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-maven-

      - name: Set up JDK 11
        if: steps.changed.outputs.changed == 'true'
        uses: actions/setup-java@v3
        with:
          java-version: '11'
          distribution: 'adopt'
          cache: maven

      - name: Build ${{ matrix.service }}
        if: steps.changed.outputs.changed == 'true'
        run: |
          if [ -d "${{ matrix.service }}" ] && [ -f "${{ matrix.service }}/pom.xml" ]; then
            cd ${{ matrix.service }}
            export MAVEN_OPTS="-Xmx1024m -XX:MaxMetaspaceSize=256m"
            mvn clean package -DskipTests -T 1C
          fi

      - name: Upload build artifact
        if: steps.changed.outputs.changed == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.service }}-build
          path: ${{ matrix.service }}/target/*.jar
          retention-days: 1

  build-docker-images:
    needs: [build-services, set-env]
    if: github.event_name == 'push'
    runs-on: ubuntu-latest
    strategy:
      max-parallel: 2
      matrix:
        service: [user-service, product-service, payment-service, shipping-service, favourite-service, api-gateway, service-discovery, order-service, cloud-config, proxy-client]
    name: Build Docker - ${{ matrix.service }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check if service changed
        id: changed
        run: |
          if [ -z "${{ github.event.before }}" ] || [ "${{ github.event.before }}" == "0000000000000000000000000000000000000000" ]; then
            echo "changed=true" >> $GITHUB_OUTPUT
          else
            if git diff --name-only ${{ github.event.before }} ${{ github.sha }} | grep -q "^${{ matrix.service }}/"; then
              echo "changed=true" >> $GITHUB_OUTPUT
            else
              echo "changed=false" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Set up Docker Buildx
        if: steps.changed.outputs.changed == 'true'
        uses: docker/setup-buildx-action@v2

      - name: Cache Docker layers
        if: steps.changed.outputs.changed == 'true'
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ matrix.service }}-${{ github.sha }}
          restore-keys: ${{ runner.os }}-buildx-${{ matrix.service }}-

      - name: Download build artifact
        if: steps.changed.outputs.changed == 'true'
        uses: actions/download-artifact@v4
        with:
          name: ${{ matrix.service }}-build
          path: ./${{ matrix.service }}/target/

      - name: Login to Docker Hub
        if: steps.changed.outputs.changed == 'true'
        uses: docker/login-action@v2
        with:
          username: ${{ env.DOCKER_USERNAME }}
          password: ${{ env.DOCKER_PASSWORD }}

      - name: Build and push Docker image
        if: steps.changed.outputs.changed == 'true'
        uses: docker/build-push-action@v4
        with:
          context: ./${{ matrix.service }}
          push: true
          tags: |
            ${{ env.DOCKER_USERNAME }}/${{ matrix.service }}:${{ needs.set-env.outputs.IMAGE_TAG }}
            ${{ env.DOCKER_USERNAME }}/${{ matrix.service }}:latest
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache-new,mode=max

      # Trivy Scan solo si es dev y cambió
      - name: Scan Docker image
        if: steps.changed.outputs.changed == 'true' && needs.set-env.outputs.IMAGE_TAG == 'dev'
        uses: aquasecurity/trivy-action@0.11.2
        with:
          image-ref: ${{ env.DOCKER_USERNAME }}/${{ matrix.service }}:${{ needs.set-env.outputs.IMAGE_TAG }}
          format: table
          exit-code: 0
          vuln-type: 'os,library'
          severity: 'CRITICAL'

      - name: Move cache
        if: steps.changed.outputs.changed == 'true'
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache

  validate-charts:
    needs: build-docker-images
    runs-on: ubuntu-latest
    name: Validate Helm Charts
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Helm
        uses: azure/setup-helm@v3
        with:
          version: ${{ env.HELM_VERSION }}

      # 1. Validar el Chart "Padre" (Umbrella) con los valores de CI
      # Esta es la validación más importante para asegurar que values-ci.yaml es compatible
      - name: Helm lint Umbrella Chart
        run: |
          helm lint ./helm/ecommerce -f ${{ needs.set-env.outputs.VALUES_FILE }} --set global.targetEnvironment=dev

      # 2. Validar subcharts individualmente (opcional, sin values-ci para evitar errores de scope)
      - name: Helm lint Subcharts
        run: |
          for chart in helm/ecommerce/charts/*; do
            if [ -d "$chart" ]; then
              echo "Linting $(basename $chart)..."
              helm lint "$chart"
            fi
          done

  deploy-and-test:
    needs: [validate-charts, set-env]
    runs-on: ubuntu-latest
    name: Deploy & Smoke Tests
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Necesario para git diff

      - name: Set up Helm
        uses: azure/setup-helm@v3
        with:
          version: ${{ env.HELM_VERSION }}

      - name: Set up Kind
        uses: engineerd/setup-kind@v0.6.2
        with:
          version: ${{ env.KIND_VERSION }}

      - name: Create Kind cluster
        run: |
          kind create cluster --name ecommerce-ci --wait 60s

      - name: Detect changes and set tags
        id: detect-changes
        run: |
          # Lista de servicios mapeada al nombre de la carpeta
          SERVICES="service-discovery cloud-config api-gateway product-service user-service payment-service shipping-service favourite-service order-service proxy-client"
          
          DEFAULT_TAG="${{ needs.set-env.outputs.IMAGE_TAG }}"
          
          # Inicializar variables de output
          for SERVICE in $SERVICES; do
            # Convertir service-name a SERVICE_NAME_TAG
            VAR_NAME=$(echo "$SERVICE" | tr '[:lower:]-' '[:upper:]_')_TAG
            
            # Chequear si hubo cambios en la carpeta del servicio
            if git diff --name-only ${{ github.event.before }} ${{ github.sha }} | grep -q "^$SERVICE/"; then
               echo "Service $SERVICE changed. Using tag: $DEFAULT_TAG"
               echo "$VAR_NAME=$DEFAULT_TAG" >> $GITHUB_ENV
            else
               # OPTIMIZACIÓN: Si no cambió, usamos el mismo tag (o 'latest')
               # Usar 'feature-monitoring' aquí es riesgoso si esa imagen no existe.
               # Usamos el tag de la rama actual por seguridad.
               echo "Service $SERVICE not changed. Using fallback tag: $DEFAULT_TAG"
               echo "$VAR_NAME=$DEFAULT_TAG" >> $GITHUB_ENV
            fi
          done

      - name: Helm deploy ecommerce
        run: |
          # Aquí está la clave de tu petición:
          # 1. ./helm/ecommerce -> Carga los defaults del chart
          # 2. -f values-ci.yaml -> SOBREESCRIBE los defaults
          # 3. --set ... -> SOBREESCRIBE todo lo anterior (máxima prioridad para tags dinámicos)
          
          helm upgrade --install my-ecommerce ./helm/ecommerce \
            -f ${{ needs.set-env.outputs.VALUES_FILE }} \
            --set global.targetEnvironment=dev \
            --set service-discovery.image.tag=${{ env.SERVICE_DISCOVERY_TAG }} \
            --set cloud-config.image.tag=${{ env.CLOUD_CONFIG_TAG }} \
            --set api-gateway.image.tag=${{ env.API_GATEWAY_TAG }} \
            --set product-service.image.tag=${{ env.PRODUCT_SERVICE_TAG }} \
            --set user-service.image.tag=${{ env.USER_SERVICE_TAG }} \
            --set payment-service.image.tag=${{ env.PAYMENT_SERVICE_TAG }} \
            --set shipping-service.image.tag=${{ env.SHIPPING_SERVICE_TAG }} \
            --set favourite-service.image.tag=${{ env.FAVOURITE_SERVICE_TAG }} \
            --set order-service.image.tag=${{ env.ORDER_SERVICE_TAG }} \
            --set proxy-client.image.tag=${{ env.PROXY_CLIENT_TAG }}

      # ===== ESPERAS Y VERIFICACIONES (Optimizado para legibilidad) =====

      - name: Wait for Infrastructure (Eureka & Config)
        run: |
          echo "Waiting for Eureka..."
          kubectl wait --for=condition=Ready pod -l app.kubernetes.io/name=service-discovery -n dev --timeout=180s || echo "Warning: Eureka timeout wait"
          
          echo "Waiting for Cloud Config..."
          kubectl wait --for=condition=Ready pod -l app.kubernetes.io/name=cloud-config -n dev --timeout=180s || echo "Warning: Config timeout wait"
          
          # Pausa táctica para registro en Eureka
          sleep 45

      - name: Wait for Microservices
        run: |
          kubectl wait --for=condition=Ready pod --all -n dev --timeout=300s
          # Tiempo extra para que Spring Boot termine de levantar contextos
          sleep 60

      - name: Debug Cluster State
        if: always()
        run: |
          kubectl get pods -o wide -n dev
          kubectl get svc -n dev

      - name: Run Smoke Tests (via Test Pod)
        run: |
          # Creamos un pod efímero con curl
          kubectl run test-pod -n dev --image=curlimages/curl:latest --restart=Never --command -- sleep 3600
          kubectl wait -n dev --for=condition=Ready pod/test-pod --timeout=60s
          
          echo "--- Testing Eureka Health ---"
          kubectl exec test-pod -n dev -- curl -s -f http://my-ecommerce-service-discovery.dev.svc.cluster.local:8761/actuator/health || echo "Eureka Health Failed"
          
          echo "--- Testing API Gateway Route (Product) ---"
          kubectl exec test-pod -n dev -- curl -v http://my-ecommerce-api-gateway.dev.svc.cluster.local:8080/app/api/products || echo "Gateway Test Failed"

      - name: Cleanup
        if: always()
        run: kubectl delete pod test-pod -n dev --ignore-not-found